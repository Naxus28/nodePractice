{
  "_args": [
    [
      {
        "raw": "../myLoggerModule",
        "scope": null,
        "escapedName": null,
        "name": null,
        "rawSpec": "../myLoggerModule",
        "spec": "/Users/imtloaner317/Desktop/practice/nodeREPLSnippets/myLoggerModule",
        "type": "directory"
      },
      "/Users/imtloaner317/Desktop/practice/nodeREPLSnippets/test"
    ]
  ],
  "_from": "../myLoggerModule",
  "_id": "logger@0.1.0",
  "_inCache": true,
  "_location": "/logger",
  "_phantomChildren": {},
  "_requested": {
    "raw": "../myLoggerModule",
    "scope": null,
    "escapedName": null,
    "name": null,
    "rawSpec": "../myLoggerModule",
    "spec": "/Users/imtloaner317/Desktop/practice/nodeREPLSnippets/myLoggerModule",
    "type": "directory"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "file:../myLoggerModule",
  "_shasum": "5c7e823b9f4190b32fb1887831c0b228988e8611",
  "_shrinkwrap": null,
  "_spec": "../myLoggerModule",
  "_where": "/Users/imtloaner317/Desktop/practice/nodeREPLSnippets/test",
  "author": {
    "name": "Gabriel Ferraz"
  },
  "dependencies": {},
  "description": "A simple utility module that prints to the console",
  "devDependencies": {},
  "keywords": [
    "logger",
    "console.log"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "logger",
  "optionalDependencies": {},
  "readme": "**Steps to create a module (our module will be a simple utility that logs messages to the console)**\n\n1.) **mkdir logger**\n\n2.) **cd logger && npm init**\n\n3.) fill out the questions (change version to 0.1.0 and license to MIT if applicable)\n\n4.) write code on the entry point file 'index.js' (we can have other files with utility methods and require those files in 'index.js')\n\n5.) index.js needs to export the functionality we built as methods. Modules can be exported in different ways. It is important to know if the module exported is the method itself and can be invoked directly (i.e. logger('Hello World')) or if the module is an object in which the function is a key/pair value. Because modules normally perform more than one action, they are normally exported as objects with many functions, like so:\n```javascript\nmodule.exports = {\n\tlog: function(value) {\n\t\tconsole.log(value)\n\t},\n\tanotherFunctionHere: function() {\n\t\t// do something\n\t},\n\tetc\n}\n\n// usage:\nvar logger = require('logger');\nlogger.log('Hello World'));\n\n// a module can also export its member functions individually such as below. Like in the case above, the methods exported here can't be accessed directly because they are members of the exported module object\n\n// ES6\nexports.log = (value) => console.log(value); // or\n\n// or ES5\nexports.log = function (value) { console.log(value); };\n\n\n// usage:\nvar logger = require('logger');\nlogger.log('Hello World')); //should log 'Hello World' on the console\n```\n\nThe 'logger' module will only perform one function: log messages to the console. We can therefore export the method in such a way that we can use it directly (keep in mind this is not the case for the majorioty of modules. I am just doing it this way to illustrate how 'exports' works):\n```javascript\n// ES6\nvar log = (value) => console.log(value);\n\n// or ES5\nfunction log(value) { console.log(value); }\n\n// export the 'log' method as the module itself\nmodule.exports = log;\n\n\n// usage:\nvar log = require('logger');\nlog('Hello World')); //should log 'Hello World' on the console\n```\n\n**Test module (_There are different ways to test the module_)**\n\n\n-----1-----\n\n1.) **mkdir testmodule && cd testmodule**\n\n2.) **npm install ../myLoggerModule** (assuming '/test' and '/myLoggerModule' are at the same level)\n\n3.) enter the node REPL by typing **node** on the terminal window\n\n4.) > var logger = require('logger'); //assuming you used the name node suggested when you initiated the 'logger' package (when you create the package.json for the module, node uses the same name as the parent directory by default. In this case I changed the name from 'myLoggerModule' to 'logger')\n\n5.) > logger // this will log the 'logger' module to the console so we will know if 'logger' is an object that has member methods or if it is the method itself (log is '[Function: log]')\n\n\n```javascript\nmodule.exports = {\n\tlog: function(value) {\n\t\tconsole.log(value)\n\t},\n\tanotherFunctionHere: function() {\n\t\t// do something\n\t},\n\tetc\n}\n\n// usage:\nvar logger = require('logger');\nlogger.log('Hello World'));\n\n// a module can also export its member functions individually such as below. Like in the case above, the methods exported here can't be accessed directly because they are members of the exported module object\n\n// ES6\nexports.log = (value) => console.log(value); // or\n\n// or ES5\nexports.log = function (value) { console.log(value); };\n\n\n// usage:\nvar logger = require('logger');\nlogger.log('Hello World')); //should log 'Hello World' on the console\n```\n\nThe 'logger' module will only perform one function: log messages to the console. We can therefore export the method in such a way that we can use it directly (keep in mind this is not the case for the majorioty of modules. I am just doing it this way to illustrate how 'exports' works):\n```javascript\n// ES6\nvar log = (value) => console.log(value);\n\n// or ES5\nfunction log(value) { console.log(value); }\n\n// export the 'log' method as the module itself\nmodule.exports = log;\n\n\n// usage:\nvar log = require('logger');\nlog('Hello World')); //should log 'Hello World' on the console\n```\n\n-----2-----\n\n1.) Same as above\n\n2.) **npm init** (use default options since this directory is just for testing)\n\n3.) **npm install ../myLoggerModule --save-dev** (when this is finished you should see 'logger' as a dependency in your package.json)\n\n4.) **vim/nano index.js** (file name doesn't matter here because I ran the script manually for testing but use 'index.js' for good practice)\n\n5.) Write the code for test.js:\n```javascript\n// invoke the method as a member of the module or as the module itself(depending on how the module was exported--see item 5 above)\nvar logger = require('logger');\nlogger.log('Hello World'));\n\n// or\n\nvar log = require('logger')\nlog('Hello World');\n```\n\n6.) On the terminal window, run **node index** (you should see 'Hello World' loggered on terminal)\n\n\n**Items you need to publish a module**\n\n\n1.) The module itself\n\n2.) package.json complete (with a git repo)\n\n3.) Test code\n\n4.) A README.md file describing the module and explaining how to use it\n\n\n\n",
  "readmeFilename": "README.md",
  "scripts": {
    "test": "mocha"
  },
  "version": "0.1.0"
}
